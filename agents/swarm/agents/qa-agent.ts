/**
 * QA Agent
 * Automatically creates and updates tests for features
 */

import { BaseAgent } from './base-agent';
import { swarmManager } from '../swarm-manager';
import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export class QAAgent extends BaseAgent {
  protected async execute(): Promise<void> {
    const session = swarmManager.loadSession(this.sessionId);
    if (!session) throw new Error('Session not found');

    this.updateProgress(10, 'Analyzing feature for test coverage...');

    // Analyze feature name and existing code
    const featureName = session.featureName;
    const testType = this.determineTestType(featureName);

    this.updateProgress(30, `Creating ${testType} tests...`);

    // Find or create test files
    const testFiles = await this.findOrCreateTestFiles(featureName, testType);

    this.updateProgress(50, 'Generating test cases...');

    // Generate test cases based on feature
    for (const testFile of testFiles) {
      await this.generateTestCases(testFile, featureName, testType);
    }

    this.updateProgress(70, 'Running tests...');

    // Run the tests
    const testResults = await this.runTests(testType);

    this.updateProgress(90, 'Analyzing test results...');

    // Analyze and fix failing tests
    if (testResults.failedCount > 0) {
      await this.fixFailingTests(testResults);
    }

    this.updateProgress(100, 'QA validation completed');

    // Update task with results
    this.updateTask('COMPLETED', {
      testsCreated: testFiles.length,
      testsPassed: testResults.passedCount,
      testsFailed: testResults.failedCount,
      coverage: testResults.coverage
    });
  }

  private determineTestType(featureName: string): 'e2e' | 'integration' | 'unit' {
    const lower = featureName.toLowerCase();

    if (lower.includes('ui') || lower.includes('flow') || lower.includes('user')) {
      return 'e2e';
    } else if (lower.includes('api') || lower.includes('service')) {
      return 'integration';
    } else {
      return 'unit';
    }
  }

  private async findOrCreateTestFiles(featureName: string, testType: string): Promise<string[]> {
    const testDir = path.join(process.cwd(), 'tests', testType);
    const featureSlug = featureName.toLowerCase().replace(/\s+/g, '-');

    // Search for existing test files
    const existingTests = this.searchTestFiles(testDir, featureSlug);

    if (existingTests.length > 0) {
      this.log(`Found ${existingTests.length} existing test file(s)`);
      return existingTests;
    }

    // Create new test file
    const newTestFile = path.join(testDir, `${featureSlug}.spec.ts`);
    this.log(`Creating new test file: ${newTestFile}`);

    return [newTestFile];
  }

  private searchTestFiles(dir: string, pattern: string): string[] {
    const files: string[] = [];

    if (!fs.existsSync(dir)) return files;

    const items = fs.readdirSync(dir, { withFileTypes: true });

    for (const item of items) {
      const fullPath = path.join(dir, item.name);

      if (item.isDirectory()) {
        files.push(...this.searchTestFiles(fullPath, pattern));
      } else if (item.name.includes(pattern) && item.name.endsWith('.spec.ts')) {
        files.push(fullPath);
      }
    }

    return files;
  }

  private async generateTestCases(
    testFile: string,
    featureName: string,
    testType: string
  ): Promise<void> {
    // Check if file exists
    const fileExists = fs.existsSync(testFile);

    if (fileExists) {
      this.log(`Updating existing test: ${path.basename(testFile)}`);
      // TODO: Parse and update existing tests
      return;
    }

    // Create new test file
    const template = this.getTestTemplate(featureName, testType);

    fs.mkdirSync(path.dirname(testFile), { recursive: true });
    fs.writeFileSync(testFile, template);

    this.log(`Created test file: ${path.basename(testFile)}`);
  }

  private getTestTemplate(featureName: string, testType: string): string {
    const featureSlug = featureName.toLowerCase().replace(/\s+/g, '-');

    if (testType === 'e2e') {
      return `import { test, expect } from '@playwright/test';

/**
 * E2E Tests for ${featureName}
 * Auto-generated by QA Agent
 */

test.describe('${featureName}', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
  });

  test('should load ${featureName} successfully', async ({ page }) => {
    // TODO: Add test implementation
    expect(page).toBeTruthy();
  });

  test('should interact with ${featureName}', async ({ page }) => {
    // TODO: Add test implementation
    expect(page).toBeTruthy();
  });

  test('should handle errors in ${featureName}', async ({ page }) => {
    // TODO: Add test implementation
    expect(page).toBeTruthy();
  });
});
`;
    } else if (testType === 'integration') {
      return `import { describe, it, expect } from '@jest/globals';

/**
 * Integration Tests for ${featureName}
 * Auto-generated by QA Agent
 */

describe('${featureName}', () => {
  it('should integrate with system', () => {
    // TODO: Add test implementation
    expect(true).toBeTruthy();
  });

  it('should handle API calls', () => {
    // TODO: Add test implementation
    expect(true).toBeTruthy();
  });
});
`;
    } else {
      return `import { describe, it, expect } from '@jest/globals';

/**
 * Unit Tests for ${featureName}
 * Auto-generated by QA Agent
 */

describe('${featureName}', () => {
  it('should work correctly', () => {
    // TODO: Add test implementation
    expect(true).toBeTruthy();
  });

  it('should handle edge cases', () => {
    // TODO: Add test implementation
    expect(true).toBeTruthy();
  });
});
`;
    }
  }

  private async runTests(testType: string): Promise<{
    passedCount: number;
    failedCount: number;
    coverage: number;
  }> {
    try {
      const command = testType === 'e2e'
        ? 'npx playwright test'
        : 'npm run test';

      const { stdout, stderr } = await execAsync(command, {
        timeout: 120000 // 2 minutes
      });

      // Parse results (simplified)
      const passedMatch = stdout.match(/(\d+) passed/);
      const failedMatch = stdout.match(/(\d+) failed/);

      return {
        passedCount: passedMatch ? parseInt(passedMatch[1]) : 0,
        failedCount: failedMatch ? parseInt(failedMatch[1]) : 0,
        coverage: 0 // TODO: Parse coverage
      };
    } catch (error) {
      this.log(`Test execution error: ${error}`);
      return {
        passedCount: 0,
        failedCount: 0,
        coverage: 0
      };
    }
  }

  private async fixFailingTests(testResults: any): Promise<void> {
    this.log('Analyzing failing tests...');
    // TODO: Implement test fixing logic
    // This would analyze error messages and attempt to fix common issues
  }
}
